import * as fs from 'fs'
import { Css } from './Css'
import { createClassUtils } from './class-utils/index.js'
import { createDogtailCssCompiler, CssCompiler } from './dogtailcss.js'
import { Theme } from './theme/index.js'
import { createDiffTracker } from './diffTracker.js'

export function createCssFile(
  file: fs.PathLike,
  theme: Theme,
  compiler?: CssCompiler
): Css {
  const compile =
    compiler ||
    createDogtailCssCompiler(createClassUtils(), theme, {
      tabSize: 4,
      screenAutoLevel: true,
    })

  const cssCache = new Map<string, any>()

  const css = {
    normal: new Map<string, string>(),
  } as { [key: string]: Map<string, string> }

  for (let screen of theme.screens) {
    css[screen.name] = new Map<string, string>()
  }

  let diffTracker = createDiffTracker()

  let modified = false

  return {
    add(id: string, classes: Set<string>) {
      let { classesToAdd, classesToDelete } = diffTracker.add(id, classes)
      if (classesToAdd.length || classesToDelete.length) modified = true

      for (let classToDelete of classesToDelete) {
        let cacheObj = cssCache.get(classToDelete)
        if (cacheObj) {
          cacheObj.linkCounter -= 1
          if (cacheObj.linkCounter < 1) {
            cssCache.delete(classToDelete)
            css[cacheObj.screen].delete(classToDelete)
          }
        }
      }

      for (let className of classesToAdd) {
        if (cssCache.has(className)) {
          // add linkCounter
          let cacheObj = cssCache.get(className)
          cacheObj.linkCounter += 1
        } else {
          let { screen = 'normal', rule } = compile(className)
          if (rule) {
            cssCache.set(className, {
              screen,
              rule,
              linkCounter: 1, // smart pointer
            })
            css[screen].set(className, rule)
          }
        }
      }
    },
    delete(id: string) {
      let { classesToDelete } = diffTracker.delete(id)
      if (classesToDelete.length) modified = true
      for (let classToDelete of classesToDelete) {
        let cacheObj = cssCache.get(classToDelete)
        if (cacheObj) {
          cacheObj.linkCounter -= 1
          if (cacheObj.linkCounter < 1) {
            cssCache.delete(classToDelete)
            css[cacheObj.screen].delete(classToDelete)
          }
        }
      }
    },

    render(): string {
      const cssHeader = '/* dogtailcss autogenerated file */\n\n'
      let cssArray: string[] = [cssHeader]

      for (let [_, rule] of css.normal) {
        cssArray.push(rule)
        cssArray.push('\n')
      }

      for (let screen of theme.screens) {
        cssArray.push(`@media (min-width: ${screen.minWidth}px) {\n`)
        if (css[screen.name]) {
          for (let [_, rule] of css[screen.name]) {
            cssArray.push(rule)
            cssArray.push('\n')
          }
        }
        cssArray.push('}\n')
      }
      return cssArray.join('')
    },
    apply() {
      if (!modified) return Promise.resolve()
      return fs.promises
        .writeFile(file, this.render(), { encoding: 'utf-8' })
        .then(() => {
          modified = false
        })
        .catch((err) => {
          console.error(err + '\nFailed to write file "' + file + '"')
          throw err
        })
    },
    applySync() {
      if (!modified) return
      try {
        fs.writeFileSync(file, this.render(), { encoding: 'utf-8' })
      } catch (err) {
        //TODO handle error
        console.error(err + '\nFailed to write file "' + file + '"')
      }

      modified = false
    },
  }
}
